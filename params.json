{"name":"Reflect","tagline":"Fluent Reflection - No more Reflection Boiler Plate","body":"# Reflect 1.0.0\r\n====\r\n\r\n*Fluent Reflection - Get rid of the messy boiler plate!\r\n\r\n## Setup\r\n\r\nMaven Dependency Setup\r\n\r\nCurrent Release - 1.0.0\r\n```xml\r\n<dependency>\r\n\t<groupId>org.pacesys</groupId>\r\n\t<artifactId>reflect</artifactId>\r\n\t<version>1.0.0</version>\r\n</dependency>\r\n```\r\n\r\nCurrent Snapshot (Development) - 1.0.1-SNAPSHOT\r\n```xml\r\n<dependency>\r\n\t<groupId>org.pacesys</groupId>\r\n\t<artifactId>reflect</artifactId>\r\n\t<version>1.0.1-SNAPSHOT</version>\r\n</dependency>\r\n```\r\n## Field Recipes\r\n\r\n**Finding All Fields**\r\n\r\nThis will return all fields from all super classes (public and private)\r\n```java\r\nList<Field> fields = Reflect.on(someClass).fields().all();\r\n````\r\n\r\n**Finding All Fields based on an Annotation**\r\n\r\nThis will find all fields that have been annotated with the specified annotation in the class hierarchy. \r\n```java\r\nList<Field> fields = Reflect.on(someClass).fields().annotatedWith(annotation);\r\n````\r\n\r\n**Single Field**\r\n\r\nWill find a single field based on the specified name\r\n```java\r\nField f = Reflect.on(someClass).fields().named(fieldName);\r\n````\r\n\r\n**Matching based on a Predicate**\r\n\r\nA predicate will allow you to control what is matched and what should be discarded during inspection.  Each field found in the hierarchy will be passed to the predicate to return either a true (matched) or false to discard.  The matched list will be returned\r\n```java\r\nPredicate<Field> predicate = new Predicate<Field>() {\r\n\tpublic boolean apply(Field field) {\r\n\t  if (field.isEnumConstant() || someOtherEval)\r\n\t  \treturn true;\r\n\t  return false;\r\n\t}\r\n};\r\n\r\nList<Field> fields = Reflect.on(someClass).fields().match(predicate);\r\n````\r\n**Public Only Fields**\r\n\r\nFinds only public based fields within the class hierarchy\r\n```java\r\nList<Field> fields = Reflect.on(someClass).fields().publicOnly();\r\n````\r\n## Method Recipes\r\n\r\nThe method finder has two modes in the builder chain.  Each mode provides the same chained options.\r\n\r\n```java\r\n// Finds static and instance based methods\r\nReflect.on(someClass).methods().chain //...\r\n\r\n// Finds ONLY static methods\r\nReflect.on(someClass).methods(true).chain //...\r\n````\r\n**Finding All Methods**\r\n\r\nThis will return all methods from all super classes (public and private)\r\n```java\r\nList<Method> methods = Reflect.on(someClass).methods().all();\r\n````\r\n**Finding Accessors and Mutators**\r\n\r\nThe following call will find all Java Bean based Accessor/Mutator methods for the full class hierarchy\r\n```java\r\n// Map of Name to Method\r\nMap<String,Method> accessors = Reflect.on(someClass).methods().accessors();\r\n\r\n// Map of Name to Method\r\nMap<String,Method> mutators = Reflect.on(someClass).methods().mutators();\r\n````\r\n**Finding Methods based on an Annotation**\r\n\r\nThis will find all methods that have been annotated with the specified annotation in the current class only\r\n```java\r\nList<Method> methods = Reflect.on(someClass).methods().annotatedWith(annotation);\r\n````\r\nThis will find all methods that have been annotated with the specified annotation in the class hierarchy (current class and superclasses)\r\n```java\r\nList<Method> methods = Reflect.on(someClass).methods().annotatedWithRecursive(annotation);\r\n````\r\n**Matching Methods based on a Predicate**\r\n\r\nA predicate will allow you to control what is matched and what should be discarded during inspection.  Each method found will be passed to the predicate to return either a true (matched) or false to discard.  The matched list will be returned\r\n```java\r\nPredicate<Method> predicate = new Predicate<Method>() {\r\n\tpublic boolean apply(Method method) {\r\n\t  if (method equals something)\r\n\t  \treturn true;\r\n\t  return false;\r\n\t}\r\n};\r\n\r\nList<Method> methods = Reflect.on(someClass).methods().match(predicate);\r\n````\r\n**Public Only Methods**\r\n\r\nFinds only public based methods within the class\r\n```java\r\nList<Method> methods = Reflect.on(someClass).methods().publicOnly();\r\n````\r\n**Calling a Method**\r\n\r\nThe following shows how to easily call a method and get back Generic type T as a result. \r\n```java\r\n// No Arguments - returns T (in example SomeResult)\r\nSomeResult something = Reflect.on(method).against(new Object()).call(); \r\n\r\n// With Arguments - returns T (in example SomeResult)\r\nSomeResult something = Reflect.on(method).against(new Object()).call(myVarArgs);\r\n````\r\n## Keeping Reflect for many calls\r\n\r\nIf you have many lookups such as finding Fields, Methods and calling methods it's more efficient to hold onto Reflect while using it against the current class.\r\n\r\n```java\r\nReflect r = Reflect.on(someClass);\r\nMap<String,Method> mutators = r.methods().mutators();\r\n\r\nif (mutators.containsKey(\"name\"))\r\n  Reflect.on(mutators.get(\"name\")).against(someClassInstance).call(\"Jeff\");\r\n\r\nField f = r.fields().named(\"myField\");\r\n// etc\r\n````\r\n\r\n# License\r\n\r\nReflect is licensed under MIT.  See License.txt for license.  Copyright 2013, Jeremy Unruh\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}